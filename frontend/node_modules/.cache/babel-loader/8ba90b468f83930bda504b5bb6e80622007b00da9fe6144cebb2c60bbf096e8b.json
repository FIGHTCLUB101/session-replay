{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\PRIYAM\\\\OneDrive\\\\Desktop\\\\session replay\\\\frontend\\\\src\\\\components\\\\Recorder.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\nimport * as rrweb from 'rrweb';\nimport api from '../api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function Recorder() {\n  _s();\n  const [recording, setRecording] = useState(false);\n  const sessionIdRef = useRef(null);\n  const eventsBufferRef = useRef([]);\n  const flushInterval = 5000; // Flush every 5 seconds\n\n  useEffect(() => {\n    const startSession = async () => {\n      try {\n        // Create session metadata on the server\n        const browserInfo = {\n          userAgent: navigator.userAgent,\n          language: navigator.language\n        };\n        const pageUrl = window.location.href;\n        const res = await api.post('/sessions/start', {\n          pageUrl,\n          browserInfo\n        });\n        sessionIdRef.current = res.data.sessionId;\n        setRecording(true);\n\n        // Start rrweb recording\n        rrweb.record({\n          emit(event) {\n            // Store raw rrweb events directly\n            eventsBufferRef.current.push(event);\n          },\n          maskAllInputs: true,\n          recordCanvas: true,\n          // optional: if your site uses canvas\n          inlineStylesheet: true // better for replay consistency\n        });\n      } catch (err) {\n        console.error('Failed to start session:', err);\n      }\n    };\n    startSession();\n\n    // Periodically flush events to the server\n    const intervalId = setInterval(async () => {\n      if (!recording || eventsBufferRef.current.length === 0) return;\n      const toSend = eventsBufferRef.current.splice(0);\n      try {\n        await api.post(`/sessions/${sessionIdRef.current}/events`, {\n          events: toSend\n        });\n      } catch (err) {\n        console.error('Failed to send events', err);\n      }\n    }, flushInterval);\n\n    // On unmount or page close\n    return () => {\n      clearInterval(intervalId);\n      const finalize = async () => {\n        if (eventsBufferRef.current.length > 0) {\n          try {\n            await api.post(`/sessions/${sessionIdRef.current}/events`, {\n              events: eventsBufferRef.current\n            });\n          } catch (err) {\n            console.error('Failed to send final events', err);\n          }\n        }\n        await api.post(`/sessions/${sessionIdRef.current}/end`);\n      };\n      finalize();\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Recording Session\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 70,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"Session ID: \", sessionIdRef.current]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 71,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"Do not close this page during recording.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 72,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 69,\n    columnNumber: 5\n  }, this);\n}\n_s(Recorder, \"RxY14PPLgJK2XHJBzQpSybM7ao8=\");\n_c = Recorder;\nvar _c;\n$RefreshReg$(_c, \"Recorder\");","map":{"version":3,"names":["React","useEffect","useRef","useState","rrweb","api","jsxDEV","_jsxDEV","Recorder","_s","recording","setRecording","sessionIdRef","eventsBufferRef","flushInterval","startSession","browserInfo","userAgent","navigator","language","pageUrl","window","location","href","res","post","current","data","sessionId","record","emit","event","push","maskAllInputs","recordCanvas","inlineStylesheet","err","console","error","intervalId","setInterval","length","toSend","splice","events","clearInterval","finalize","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/PRIYAM/OneDrive/Desktop/session replay/frontend/src/components/Recorder.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\r\nimport * as rrweb from 'rrweb';\r\nimport api from '../api';\r\n\r\nexport default function Recorder() {\r\n  const [recording, setRecording] = useState(false);\r\n  const sessionIdRef = useRef(null);\r\n  const eventsBufferRef = useRef([]);\r\n  const flushInterval = 5000; // Flush every 5 seconds\r\n\r\n  useEffect(() => {\r\n    const startSession = async () => {\r\n      try {\r\n        // Create session metadata on the server\r\n        const browserInfo = { userAgent: navigator.userAgent, language: navigator.language };\r\n        const pageUrl = window.location.href;\r\n        const res = await api.post('/sessions/start', { pageUrl, browserInfo });\r\n        sessionIdRef.current = res.data.sessionId;\r\n        setRecording(true);\r\n\r\n        // Start rrweb recording\r\n        rrweb.record({\r\n          emit(event) {\r\n            // Store raw rrweb events directly\r\n            eventsBufferRef.current.push(event);\r\n          },\r\n          maskAllInputs: true,\r\n          recordCanvas: true, // optional: if your site uses canvas\r\n          inlineStylesheet: true, // better for replay consistency\r\n        });\r\n      } catch (err) {\r\n        console.error('Failed to start session:', err);\r\n      }\r\n    };\r\n\r\n    startSession();\r\n\r\n    // Periodically flush events to the server\r\n    const intervalId = setInterval(async () => {\r\n      if (!recording || eventsBufferRef.current.length === 0) return;\r\n      const toSend = eventsBufferRef.current.splice(0);\r\n      try {\r\n        await api.post(`/sessions/${sessionIdRef.current}/events`, { events: toSend });\r\n      } catch (err) {\r\n        console.error('Failed to send events', err);\r\n      }\r\n    }, flushInterval);\r\n\r\n    // On unmount or page close\r\n    return () => {\r\n      clearInterval(intervalId);\r\n      const finalize = async () => {\r\n        if (eventsBufferRef.current.length > 0) {\r\n          try {\r\n            await api.post(`/sessions/${sessionIdRef.current}/events`, {\r\n              events: eventsBufferRef.current,\r\n            });\r\n          } catch (err) {\r\n            console.error('Failed to send final events', err);\r\n          }\r\n        }\r\n        await api.post(`/sessions/${sessionIdRef.current}/end`);\r\n      };\r\n      finalize();\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div>\r\n      <h2>Recording Session</h2>\r\n      <p>Session ID: {sessionIdRef.current}</p>\r\n      <p>Do not close this page during recording.</p>\r\n    </div>\r\n  );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}