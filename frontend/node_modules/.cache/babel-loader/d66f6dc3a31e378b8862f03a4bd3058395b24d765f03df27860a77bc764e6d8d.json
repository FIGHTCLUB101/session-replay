{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\PRIYAM\\\\OneDrive\\\\Desktop\\\\session replay\\\\frontend\\\\src\\\\components\\\\Recorder.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\n//import rrweb from 'rrweb';\nimport * as rrweb from 'rrweb';\nimport api from '../api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function Recorder() {\n  _s();\n  const [recording, setRecording] = useState(false);\n  const sessionIdRef = useRef(null);\n  const seqRef = useRef(0);\n  const eventsBufferRef = useRef([]);\n  const flushInterval = 5000; // Flush events every 5 seconds\n\n  useEffect(() => {\n    const startSession = async () => {\n      // Create session metadata on server\n      const browserInfo = {\n        userAgent: navigator.userAgent,\n        language: navigator.language\n      };\n      const pageUrl = window.location.href;\n      const res = await api.post('/sessions/start', {\n        pageUrl,\n        browserInfo\n      });\n      sessionIdRef.current = res.data.sessionId;\n      setRecording(true);\n\n      // Initialize rrweb recording\n      rrweb.record({\n        emit(event) {\n          const evt = {\n            seq: seqRef.current++,\n            timestamp: event.timestamp,\n            type: event.type,\n            data: event\n          };\n          eventsBufferRef.current.push(evt);\n        },\n        // Mask all inputs by default\n        maskAllInputs: true\n      });\n    };\n    startSession();\n\n    // Periodically flush events to server\n    const intervalId = setInterval(async () => {\n      if (!recording || eventsBufferRef.current.length === 0) return;\n      const toSend = eventsBufferRef.current.splice(0, eventsBufferRef.current.length);\n      try {\n        await api.post(`/sessions/${sessionIdRef.current}/events`, {\n          events: toSend\n        });\n      } catch (err) {\n        console.error('Failed to send events', err);\n      }\n    }, flushInterval);\n\n    // On unmount, send remaining events and end session\n    return () => {\n      clearInterval(intervalId);\n      const finalize = async () => {\n        if (eventsBufferRef.current.length > 0) {\n          try {\n            await api.post(`/sessions/${sessionIdRef.current}/events`, {\n              events: eventsBufferRef.current\n            });\n          } catch (err) {\n            console.error('Failed to send final events', err);\n          }\n        }\n        await api.post(`/sessions/${sessionIdRef.current}/end`);\n      };\n      finalize();\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Recording Session\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 69,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"Session ID: \", sessionIdRef.current]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 70,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"If you close this page, recording will stop.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 71,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 68,\n    columnNumber: 5\n  }, this);\n}\n_s(Recorder, \"bsL73U+tLGmxW9vwv9eaqYBJfcs=\");\n_c = Recorder;\nvar _c;\n$RefreshReg$(_c, \"Recorder\");","map":{"version":3,"names":["React","useEffect","useRef","useState","rrweb","api","jsxDEV","_jsxDEV","Recorder","_s","recording","setRecording","sessionIdRef","seqRef","eventsBufferRef","flushInterval","startSession","browserInfo","userAgent","navigator","language","pageUrl","window","location","href","res","post","current","data","sessionId","record","emit","event","evt","seq","timestamp","type","push","maskAllInputs","intervalId","setInterval","length","toSend","splice","events","err","console","error","clearInterval","finalize","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/PRIYAM/OneDrive/Desktop/session replay/frontend/src/components/Recorder.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\r\n//import rrweb from 'rrweb';\r\nimport * as rrweb from 'rrweb';\r\nimport api from '../api';\r\n\r\nexport default function Recorder() {\r\n  const [recording, setRecording] = useState(false);\r\n  const sessionIdRef = useRef(null);\r\n  const seqRef = useRef(0);\r\n  const eventsBufferRef = useRef([]);\r\n  const flushInterval = 5000; // Flush events every 5 seconds\r\n\r\n  useEffect(() => {\r\n    const startSession = async () => {\r\n      // Create session metadata on server\r\n      const browserInfo = { userAgent: navigator.userAgent, language: navigator.language };\r\n      const pageUrl = window.location.href;\r\n      const res = await api.post('/sessions/start', { pageUrl, browserInfo });\r\n      sessionIdRef.current = res.data.sessionId;\r\n      setRecording(true);\r\n      \r\n      // Initialize rrweb recording\r\n      rrweb.record({\r\n        emit(event) {\r\n          const evt = {\r\n            seq: seqRef.current++,\r\n            timestamp: event.timestamp,\r\n            type: event.type,\r\n            data: event,\r\n          };\r\n          eventsBufferRef.current.push(evt);\r\n        },\r\n        // Mask all inputs by default\r\n        maskAllInputs: true,\r\n      });\r\n    };\r\n    startSession();\r\n\r\n    // Periodically flush events to server\r\n    const intervalId = setInterval(async () => {\r\n      if (!recording || eventsBufferRef.current.length === 0) return;\r\n      const toSend = eventsBufferRef.current.splice(0, eventsBufferRef.current.length);\r\n      try {\r\n        await api.post(`/sessions/${sessionIdRef.current}/events`, { events: toSend });\r\n      } catch (err) {\r\n        console.error('Failed to send events', err);\r\n      }\r\n    }, flushInterval);\r\n\r\n    // On unmount, send remaining events and end session\r\n    return () => {\r\n      clearInterval(intervalId);\r\n      const finalize = async () => {\r\n        if (eventsBufferRef.current.length > 0) {\r\n          try {\r\n            await api.post(`/sessions/${sessionIdRef.current}/events`, { events: eventsBufferRef.current });\r\n          } catch (err) {\r\n            console.error('Failed to send final events', err);\r\n          }\r\n        }\r\n        await api.post(`/sessions/${sessionIdRef.current}/end`);\r\n      };\r\n      finalize();\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div>\r\n      <h2>Recording Session</h2>\r\n      <p>Session ID: {sessionIdRef.current}</p>\r\n      <p>If you close this page, recording will stop.</p>\r\n    </div>\r\n  );\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}